{
  "id": "e4fa83b3-6a45-4bd6-8edc-1af35ebeb996",
  "title": "Predict Disk Capacity",
  "description": "",
  "tasks": {
    "send_message": {
      "name": "send_message",
      "description": "",
      "action": "dynatrace.email:email-send-email",
      "input": {
        "appName": "Email Integration"
      },
      "position": {
        "x": 1,
        "y": 3
      },
      "predecessors": [
        "check_prediction"
      ],
      "conditions": {
        "states": {
          "check_prediction": "OK"
        },
        "custom": "{{ result('check_prediction').violation }}\n"
      }
    },
    "check_prediction": {
      "name": "check_prediction",
      "description": "Build a custom task running js Code",
      "action": "dynatrace.automations:run-javascript",
      "input": {
        "script": "import { execution } from '@dynatrace-sdk/automation-utils';\n\nconst THRESHOLD = 15;\nconst TASK_ID = 'predict_disk_capacity';\n\nexport default async function ({ execution_id }) {\n  const exe = await execution(execution_id);\n  const predResult = await exe.result(TASK_ID);\n  const result = predResult['result'];\n  const predictionSummary = { violation: false, violations: new Array<Record<string, string>>() };\n  console.log(\"Total number of predicted lines: \" + result.output.length);\n  // Check if prediction was successful.\n  if (result.resultStatus == 'SUCCESSFUL' && result.executionStatus == 'COMPLETED') {\n    console.log('Prediction was successful.')\n    // Check each predicted result, if it violates the threshold.\n    for (let i = 0; i < result.output.length; i++) {\n      const prediction = result.output[i];\n      // Check if the prediction result is considered valid\n      if (prediction.analysisStatus == 'OK' && prediction.forecastQualityAssessment == 'VALID') {\n        const lowerPredictions = prediction.timeSeriesDataWithPredictions.records[0]['dt.davis.forecast:lower'];\n        const lastValue = lowerPredictions[lowerPredictions.length-1];\n        // check against the threshold\n        if (lastValue < THRESHOLD) {\n          predictionSummary.violation = true;\n          // we need to remember all metric properties in the result, \n          // to inform the next actions which disk ran out of space\n          predictionSummary.violations.push(prediction.timeSeriesDataWithPredictions.records[0]);\n        }\n      }\n    }\n    console.log(predictionSummary.violations.length == 0 ? 'No violations found :)' : '' + predictionSummary.violations.length + ' capacity shortages were found!')\n    return predictionSummary;\n  } else {\n    console.log('Prediction run failed!');\n  }\n}\n"
      },
      "position": {
        "x": 0,
        "y": 2
      },
      "predecessors": [
        "predict_disk_capacity"
      ],
      "conditions": {
        "states": {
          "predict_disk_capacity": "OK"
        }
      }
    },
    "predict_disk_capacity": {
      "name": "predict_disk_capacity",
      "description": "Execute a customizable AI/ML task using DavisÂ® analyzers",
      "action": "dynatrace.davis.workflow.actions:davis-analyze",
      "input": {
        "body": {
          "nPaths": 200,
          "timeSeriesData": "timeseries avg(dt.host.disk.free), by:{dt.entity.host, dt.entity.disk}, bins: 120, from:now()-7d, to:now() | filter dt.entity.host  == \"HOST-84AD9324F2B73238\" or dt.entity.host  == \"HOST-F8D60EB24F4B9971\"",
          "forecastHorizon": 100,
          "generalParameters": {
            "timeframe": {
              "endTime": "now",
              "startTime": "now-6h"
            },
            "logVerbosity": "TRACING",
            "resolveDimensionalQueryData": false
          },
          "coverageProbability": 0.9,
          "applyZeroLowerBoundHeuristic": false
        },
        "analyzerName": "dt.statistics.GenericForecastAnalyzer"
      },
      "position": {
        "x": 0,
        "y": 1
      },
      "predecessors": []
    },
    "raise_violation_events": {
      "name": "raise_violation_events",
      "description": "Build a custom task running js Code",
      "action": "dynatrace.automations:run-javascript",
      "input": {
        "script": "import { eventsClient, EventIngestEventType } from \"@dynatrace-sdk/client-classic-environment-v2\";\nimport { execution } from '@dynatrace-sdk/automation-utils';\n\nexport default async function ({ execution_id }) {\n  const exe = await execution(execution_id);\n  const checkResult = await exe.result('check_prediction');\n  const violations = await checkResult.violations;\n  // Raise an event for each violation\n  violations.forEach(function (violation) {\n    eventsClient.createEvent({ \n      body : {\n        eventType: EventIngestEventType.ResourceContentionEvent,\n        title: 'Predicted Disk Capacity Alarm',\n        entitySelector: 'type(DISK),entityId(\"' + violation['dt.entity.disk'] + '\")',\n        properties: {\n          'dt.entity.host' : violation['dt.entity.host']\n        }\n      }\n    }); \n  });  \n};"
      },
      "position": {
        "x": -1,
        "y": 3
      },
      "predecessors": [
        "check_prediction"
      ],
      "conditions": {
        "states": {
          "check_prediction": "OK"
        },
        "custom": "{{ result('check_prediction').violation }}"
      }
    }
  },
  "ownerType": "USER",
  "isPrivate": false,
  "trigger": {
    "schedule": {
      "trigger": {
        "type": "time",
        "time": "08:00"
      },
      "timezone": "Europe/Vienna",
      "isActive": true,
      "isFaulty": false,
      "nextExecution": "2023-09-18T06:00:00.000Z",
      "filterParameters": {
        "earliestStart": "2023-03-21"
      },
      "inputs": {}
    }
  },
  "schemaVersion": 3
}